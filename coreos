#!/bin/bash

#Device selection
RED='\033[0;31m'
GREEN='\033[0;32m'
NC='\033[0m'

Device_selections() {

echo "Devices available:"
DEVICES=$(adb devices -l | grep -v "List of devices attached" | grep -v "^$")
echo "$DEVICES"

if [ -z "$DEVICES" ]; then
    echo "Error: No devices connected."
    exit 1
fi

# Prepare arrays to map serial numbers to device names
DEVICE_LIST=()
DEVICE_NAMES=()

# Populate the arrays with serial numbers and device names
while IFS= read -r line; do
    SERIAL=$(echo "$line" | awk '{print $1}')
    if [ -n "$SERIAL" ]; then
        DEVICE_NAME=$(echo "$line" | sed -e "s/^[^ ]* \(.*\)$/\1/")
        DEVICE_LIST+=("$SERIAL")
        DEVICE_NAMES+=("$DEVICE_NAME")
    fi
done <<< "$DEVICES"

# Display devices and prompt for selection
if [ ${#DEVICE_LIST[@]} -gt 1 ]; then
    echo "Multiple devices connected. Please select one:"
    PS3="Enter the number of your choice: "
    select DEVICE_SERIAL in "${DEVICE_LIST[@]}"; do
        if [ -n "$DEVICE_SERIAL" ]; then
            for i in "${!DEVICE_LIST[@]}"; do
                if [ "${DEVICE_LIST[$i]}" = "$DEVICE_SERIAL" ]; then
                    DEVICE_NAME="${DEVICE_NAMES[$i]}"
                    break
                fi
            done
            echo "Selected device: $DEVICE_NAME ($DEVICE_SERIAL)"
            break
        else
            echo "Invalid selection. Please try again."
        fi
    done
elif [ ${#DEVICE_LIST[@]} -eq 1 ]; then
    # Single device case
    DEVICE_SERIAL="${DEVICE_LIST[0]}"
    DEVICE_NAME="${DEVICE_NAMES[0]}"
    echo "Only one device connected: $DEVICE_NAME ($DEVICE_SERIAL)"
else
    echo "Error: No devices available for selection."
    exit 1
fi

}

# Function for the first script's functionality

Apex_multiuser_BA() {
Device_selections

# Ensure the script is executed on a Userdebug build
echo "Make sure you use a Userdebug build"

echo "Creating second user"
adb -s "$DEVICE_SERIAL" shell pm create-user "User Name" > /dev/null 2>&1
 
# Set the ADB target device
adb -s "$DEVICE_SERIAL" root > /dev/null

# Capture current directory


# Extract user ID
user_info=$(adb -s "$DEVICE_SERIAL" shell pm list users)
user_id=$(echo "$user_info" | grep -oP 'UserInfo{\K\d+' | tail -n 1)
if [[ -z "$user_id" ]]; then
    echo -e "${RED}Failed to extract user ID.${NC}"
    exit 1
fi
echo "Switching to second user" > /dev/null 2>&1
adb -s "$DEVICE_SERIAL" shell am switch-user ${user_id} > /dev/null 2>&1
sleep 10
adb -s "$DEVICE_SERIAL" shell am start -a com.android.setupwizard.FOUR_CORNER_EXIT > /dev/null 2>&1
sleep 10
adb -s "$DEVICE_SERIAL" shell am switch-user 0 > /dev/null 2>&1

# Create and push file to the device
echo "Welcome mainline" > push.txt
echo "Welcome mainline" > vks.txt
adb -s "$DEVICE_SERIAL" push push.txt /data/misc_de/${user_id}/apexdata/com.android.resolv > /dev/null 2>&1
adb -s "$DEVICE_SERIAL" push vks.txt /data/misc/apexdata/com.android.resolv > /dev/null 2>&1
echo "Test file pushed to Resolv root folder on  both main and second user"

# Verify if the file is pushed correctly in first user 


    command_output=$(adb -s "$DEVICE_SERIAL" shell cat /data/misc/apexdata/com.android.resolv/vks.txt)
    search_text="Welcome mainline"
    if echo "$command_output" | grep -q "$search_text"; then
        echo "Text file present in first user"
    else
        echo -e "${RED}Text file not present in first user.${NC}"
        exit 1
    fi


# Verify if the file is pushed correctly in second user 


    command_output=$(adb -s "$DEVICE_SERIAL" shell cat /data/misc_de/${user_id}/apexdata/com.android.resolv/push.txt)
    search_text="Welcome mainline"
    if echo "$command_output" | grep -q "$search_text"; then
        echo "Text file present in second user"
    else
        echo -e "${RED}Text file not present in second user.${NC}"
        exit 1
    fi

adb shell am start -n com.android.vending/com.google.android.finsky.systemupdateactivity.SystemUpdateActivity > /dev/null 2>&1

# Prompt user to reboot the device
echo -e "${GREEN}Please update the train in device and click reboot in the device.${NC}"
read -p "After the device has rebooted, Tap 'y' and Enter to continue or Tap 'n' and Enter to exit: " response

if [[ "$response" == "y" ]]; then
    echo "Continuing script..."
else
    echo -e "${RED}Exiting script.${NC}"
    exit 1
fi
# To check adb root   
        if adb -s "$DEVICE_SERIAL" get-state | grep -q "device"; then
    echo "Device is connected. Trying to execute adb root..."
    while true; do
        if adb -s "$DEVICE_SERIAL" root; then
            echo "ADB root command was successful."
            break
        else
            echo "Failed to execute adb root command. Retrying..."
            sleep 2  # Wait for 2 seconds before retrying
        fi
    done
else
    echo "Device is not connected or not recognized."
fi

# Verify if the file remains unchanged after reboot in first user  


    command_output1=$(adb -s "$DEVICE_SERIAL" shell cat /data/misc/apexdata/com.android.resolv/vks.txt)
    search_text1="Welcome mainline"
    if echo "$command_output1" | grep -q "$search_text1"; then
    echo "Pushed file remains unchanged after update to the latest train in first user"
else
    echo -e "${RED}Pushed file changed after update to the latest train in first user.${NC}"
    exit 1
fi


# Verify if the file remains unchanged after reboot in second user  


    command_output1=$(adb -s "$DEVICE_SERIAL" shell cat /data/misc_de/${user_id}/apexdata/com.android.resolv/push.txt)
    search_text1="Welcome mainline"
    if echo "$command_output1" | grep -q "$search_text1"; then
    echo "Pushed file remains unchanged after update to the latest train in second user"
else
    echo -e "${RED}Pushed file changed after update to the latest train in second user.${NC}"
    exit 1
fi

# Modify the file on the first user
echo "Edit the mainline file" > vks.txt
adb -s "$DEVICE_SERIAL" push vks.txt /data/misc/apexdata/com.android.resolv > /dev/null 2>&1
adb -s "$DEVICE_SERIAL" shell "ls /data/misc/apexdata/com.android.resolv" > /dev/null

    command_output2=$(adb -s "$DEVICE_SERIAL" shell cat /data/misc/apexdata/com.android.resolv/vks.txt)
    search_text2="Edit the mainline file"
    if echo "$command_output2" | grep -q "$search_text2"; then
    echo "Text file modified in first user"
else
    echo -e "${RED}Unable to modify test file in first user.${NC}"
    exit 1
fi

# Modify the file on the second user
echo "Edit the mainline file" > push.txt
adb -s "$DEVICE_SERIAL" push push.txt /data/misc_de/${user_id}/apexdata/com.android.resolv > /dev/null 2>&1
adb -s "$DEVICE_SERIAL" shell "ls /data/misc_de/${user_id}/apexdata/com.android.resolv" > /dev/null

    command_output2=$(adb -s "$DEVICE_SERIAL" shell cat /data/misc_de/${user_id}/apexdata/com.android.resolv/push.txt)
    search_text2="Edit the mainline file"
    if echo "$command_output2" | grep -q "$search_text2"; then
    echo "Text file modified in second user"
else
    echo -e "${RED}Unable to modify test file in second user.${NC}"
    exit 1
fi
adb -s "$DEVICE_SERIAL" shell am switch-user ${user_id} > /dev/null 2>&1
sleep 10
# Rollback 

MAX_TRIES=3
for (( i = 1; i <= MAX_TRIES; i++ )); do
    echo "Rollback Try number $i" > /dev/null 2>&1
    echo -e "${GREEN}Rolling back Primary train.${NC}"
    rollback=$(adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.android.modulemetadata)
  
    if echo "$rollback" | grep -q "Reboot"; then
        echo "Primary train rollbacked and rebooting the device, script will continue after device reboot"
        adb -s "$DEVICE_SERIAL" reboot
        echo -e "${GREEN}Device is rebooting. Waiting for it to come back online...${NC}"

        # Wait for device to come back online
        while ! adb -s "$DEVICE_SERIAL" wait-for-device; do
            sleep 5
        done

        echo -e "${GREEN}Device is back online.${NC}"
        sleep 10
        
      # To check adb root   
        if adb -s "$DEVICE_SERIAL" get-state | grep -q "device"; then
    echo "Device is connected. Trying to execute adb root..."
    while true; do
        if adb -s "$DEVICE_SERIAL" root; then
            echo "ADB root command was successful."
            break
        else
            echo "Failed to execute adb root command. Retrying..."
            sleep 2  # Wait for 2 seconds before retrying
        fi
    done
else
    echo "Device is not connected or not recognized."
fi
        
        sleep 10


        command_output1=$(adb -s "$DEVICE_SERIAL" shell cat /data/misc/apexdata/com.android.resolv/vks.txt)
        search_text1="Welcome mainline"
        if echo "$command_output1" | grep -q "$search_text1"; then
            echo -e "${GREEN}Test passed in first user.${NC}"
        else
            echo -e "${RED}Test failed in first user.${NC}"
            exit 1
        fi

        # Verify if the file is restored to its original state in second user 
        

        command_output2=$(adb -s "$DEVICE_SERIAL" shell cat /data/misc_de/${user_id}/apexdata/com.android.resolv/push.txt)
        search_text2="Welcome mainline"
        if echo "$command_output2" | grep -q "$search_text2"; then
            echo -e "${GREEN}Test passed in second user.${NC}"
        else
            echo -e "${RED}Test failed in second user.${NC}"
            exit 1
        fi
        break
    elif echo "$rollback" | grep -q "available"; then
        echo -e "${RED}Rollback unavailable; please factory reset and set up the device again.${NC}"
        exit 1
    else
        sleep 10
        echo "Unable to do rollback action, trying $((MAX_TRIES - i)) more times to rollback"
    fi
done

}

# Function for the second script's functionality
Apex_multiuser_Go() {
Device_selections

echo "Creating second user"
adb -s "$DEVICE_SERIAL" shell pm create-user "User Name" > /dev/null 2>&1
 
# Set the ADB target device
adb -s "$DEVICE_SERIAL" root > /dev/null

# Capture current directory


# Extract user ID
user_info=$(adb -s "$DEVICE_SERIAL" shell pm list users)
user_id=$(echo "$user_info" | grep -oP 'UserInfo{\K\d+' | tail -n 1)
if [[ -z "$user_id" ]]; then
    echo -e "${RED}Failed to extract user ID.${NC}"
    exit 1
fi
echo "Switching to second user" > /dev/null 2>&1
adb -s "$DEVICE_SERIAL" shell am switch-user ${user_id} > /dev/null 2>&1
sleep 10
adb -s "$DEVICE_SERIAL" shell am start -a com.android.setupwizard.FOUR_CORNER_EXIT > /dev/null 2>&1
sleep 10
adb -s "$DEVICE_SERIAL" shell am switch-user 0 > /dev/null 2>&1

# Create and push file to the device
echo "Welcome mainline" > push.txt
echo "Welcome mainline" > vks.txt
adb -s "$DEVICE_SERIAL" push push.txt /data/misc_de/${user_id}/apexdata/com.android.permission > /dev/null 2>&1
adb -s "$DEVICE_SERIAL" push vks.txt /data/misc/apexdata/com.android.permission > /dev/null 2>&1
echo "Test file pushed to permission root folder on  both main and second user"

# Verify if the file is pushed correctly in first user 


    command_output=$(adb -s "$DEVICE_SERIAL" shell cat /data/misc/apexdata/com.android.permission/vks.txt)
    search_text="Welcome mainline"
    if echo "$command_output" | grep -q "$search_text"; then
        echo "Text file present in first user"
    else
        echo -e "${RED}Text file not present in first user.${NC}"
        exit 1
    fi


# Verify if the file is pushed correctly in second user 


    command_output=$(adb -s "$DEVICE_SERIAL" shell cat /data/misc_de/${user_id}/apexdata/com.android.permission/push.txt)
    search_text="Welcome mainline"
    if echo "$command_output" | grep -q "$search_text"; then
        echo "Text file present in second user"
    else
        echo -e "${RED}Text file not present in second user.${NC}"
        exit 1
    fi

adb shell am start -n com.android.vending/com.google.android.finsky.systemupdateactivity.SystemUpdateActivity > /dev/null 2>&1

# Prompt user to reboot the device
echo -e "${GREEN}Please update the train in device and click reboot in the device.${NC}"
read -p "After the device has rebooted, Tap 'y' and Enter to continue or Tap 'n' and Enter to exit: " response

if [[ "$response" == "y" ]]; then
    echo "Continuing script..."
else
    echo -e "${RED}Exiting script.${NC}"
    exit 1
fi
# To check adb root   
        if adb -s "$DEVICE_SERIAL" get-state | grep -q "device"; then
    echo "Device is connected. Trying to execute adb root..."
    while true; do
        if adb -s "$DEVICE_SERIAL" root; then
            echo "ADB root command was successful."
            break
        else
            echo "Failed to execute adb root command. Retrying..."
            sleep 2  # Wait for 2 seconds before retrying
        fi
    done
else
    echo "Device is not connected or not recognized."
fi

# Verify if the file remains unchanged after reboot in first user  


    command_output1=$(adb -s "$DEVICE_SERIAL" shell cat /data/misc/apexdata/com.android.permission/vks.txt)
    search_text1="Welcome mainline"
    if echo "$command_output1" | grep -q "$search_text1"; then
    echo "Pushed file remains unchanged after update to the latest train in first user"
else
    echo -e "${RED}Pushed file changed after update to the latest train in first user.${NC}"
    exit 1
fi


# Verify if the file remains unchanged after reboot in second user  


    command_output1=$(adb -s "$DEVICE_SERIAL" shell cat /data/misc_de/${user_id}/apexdata/com.android.permission/push.txt)
    search_text1="Welcome mainline"
    if echo "$command_output1" | grep -q "$search_text1"; then
    echo "Pushed file remains unchanged after update to the latest train in second user"
else
    echo -e "${RED}Pushed file changed after update to the latest train in second user.${NC}"
    exit 1
fi

# Modify the file on the first user
echo "Edit the mainline file" > vks.txt
adb -s "$DEVICE_SERIAL" push vks.txt /data/misc/apexdata/com.android.permission > /dev/null 2>&1
adb -s "$DEVICE_SERIAL" shell "ls /data/misc/apexdata/com.android.permission" > /dev/null

    command_output2=$(adb -s "$DEVICE_SERIAL" shell cat /data/misc/apexdata/com.android.permission/vks.txt)
    search_text2="Edit the mainline file"
    if echo "$command_output2" | grep -q "$search_text2"; then
    echo "Text file modified in first user"
else
    echo -e "${RED}Unable to modify test file in first user.${NC}"
    exit 1
fi

# Modify the file on the second user
echo "Edit the mainline file" > push.txt
adb -s "$DEVICE_SERIAL" push push.txt /data/misc_de/${user_id}/apexdata/com.android.permission > /dev/null 2>&1
adb -s "$DEVICE_SERIAL" shell "ls /data/misc_de/${user_id}/apexdata/com.android.permission" > /dev/null

    command_output2=$(adb -s "$DEVICE_SERIAL" shell cat /data/misc_de/${user_id}/apexdata/com.android.permission/push.txt)
    search_text2="Edit the mainline file"
    if echo "$command_output2" | grep -q "$search_text2"; then
    echo "Text file modified in second user"
else
    echo -e "${RED}Unable to modify test file in second user.${NC}"
    exit 1
fi
adb -s "$DEVICE_SERIAL" shell am switch-user ${user_id} > /dev/null 2>&1
sleep 10
# Rollback 

MAX_TRIES=3
for (( i = 1; i <= MAX_TRIES; i++ )); do
    echo "Rollback Try number $i" > /dev/null 2>&1
    echo -e "${GREEN}Rolling back Primary train.${NC}"
    rollback=$(adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.mainline.go.primary
)
  
    if echo "$rollback" | grep -q "Reboot"; then
        echo "Primary train rollbacked and rebooting the device, script will continue after device reboot"
        adb -s "$DEVICE_SERIAL" reboot
        echo -e "${GREEN}Device is rebooting. Waiting for it to come back online...${NC}"

        # Wait for device to come back online
        while ! adb -s "$DEVICE_SERIAL" wait-for-device; do
            sleep 5
        done

        echo -e "${GREEN}Device is back online.${NC}"
        sleep 10
        
      # To check adb root   
        if adb -s "$DEVICE_SERIAL" get-state | grep -q "device"; then
    echo "Device is connected. Trying to execute adb root..."
    while true; do
        if adb -s "$DEVICE_SERIAL" root; then
            echo "ADB root command was successful."
            break
        else
            echo "Failed to execute adb root command. Retrying..."
            sleep 2  # Wait for 2 seconds before retrying
        fi
    done
else
    echo "Device is not connected or not recognized."
fi
        
        sleep 10


        command_output1=$(adb -s "$DEVICE_SERIAL" shell cat /data/misc/apexdata/com.android.permission/vks.txt)
        search_text1="Welcome mainline"
        if echo "$command_output1" | grep -q "$search_text1"; then
            echo -e "${GREEN}Test passed in first user.${NC}"
        else
            echo -e "${RED}Test failed in first user.${NC}"
            exit 1
        fi

        # Verify if the file is restored to its original state in second user 
        

        command_output2=$(adb -s "$DEVICE_SERIAL" shell cat /data/misc_de/${user_id}/apexdata/com.android.permission/push.txt)
        search_text2="Welcome mainline"
        if echo "$command_output2" | grep -q "$search_text2"; then
            echo -e "${GREEN}Test passed in second user.${NC}"
        else
            echo -e "${RED}Test failed in second user.${NC}"
            exit 1
        fi
        break
    elif echo "$rollback" | grep -q "available"; then
        echo -e "${RED}Rollback unavailable; please factory reset and set up the device again.${NC}"
        exit 1
    else
        sleep 10
        echo "Unable to do rollback action, trying $((MAX_TRIES - i)) more times to rollback"
    fi
done

}


sideload() {

echo "1. To install modules on single device"
echo "2. To install the modules on all the conected device"
echo "3. Exit"

read -p "Enter the number of the choice to execute (1-3): " choice

case $choice in

1)

# Call the Device_selections function
Device_selections

# Determine the current working directory
CURRENT_DIR=$(pwd)

# Set both SCRIPT_DIR and ZIP_DIR to the current working directory
SCRIPT_DIR="$CURRENT_DIR"
ZIP_DIR="$CURRENT_DIR"

# Check if any ZIP files exist
ZIP_FILES=$(find "$ZIP_DIR" -name "*.zip")

if [ -z "$ZIP_FILES" ]; then
    echo "No Train ZIP files found in the current directory. Please add the necessary files."
    exit 1
fi

# Find the latest version of bundletool-all.jar relative to SCRIPT_DIR
BUNDLETOOL_JAR=$(find "$SCRIPT_DIR" -name "bundletool-all-*.jar" | sort -V | tail -n 1)

# If bundletool is not found, download it
if [ -z "$BUNDLETOOL_JAR" ]; then
    #!/bin/bash

# Fetch the latest release page URL and extract the version tag using jq
LATEST_VERSION=$(curl -s https://api.github.com/repos/google/bundletool/releases/latest | jq -r .tag_name)

# Check if version extraction was successful
if [ -z "$LATEST_VERSION" ]; then
    echo "Failed to retrieve the latest version. Please check the GitHub API."
    exit 1
fi

# Set the download URL for the bundletool jar file
DOWNLOAD_URL="https://github.com/google/bundletool/releases/download/${LATEST_VERSION}/bundletool-all-${LATEST_VERSION}.jar"

# Download the bundletool jar file
echo "Downloading bundletool version ${LATEST_VERSION}..."
curl -L -o "bundletool-all-${LATEST_VERSION}.jar" "$DOWNLOAD_URL"

# Confirm the download
if [ -f "bundletool-all-${LATEST_VERSION}.jar" ]; then
    echo "Download completed successfully: bundletool-all-${LATEST_VERSION}.jar"
else
    echo "Download failed. Please check the URL and the file format."
fi


    BUNDLETOOL_JAR="$SCRIPT_DIR/bundletool-all-${LATEST_VERSION}.jar"
fi

# Use the selected device
echo "Using device: $DEVICE_NAME ($DEVICE_SERIAL)"


# Process each zip file in ZIP_DIR
for zip_file in "$ZIP_DIR"/*.zip; do
    if [ -f "$zip_file" ]; then
        echo "Processing $zip_file on device $DEVICE_NAME ($DEVICE_SERIAL)"
        # Ensure the device ID is passed to the command
        java -jar "$BUNDLETOOL_JAR" install-multi-apks --device-id="$DEVICE_SERIAL" --enable-rollback --update-only --apks-zip="$zip_file"
        echo -e "${GREEN}Done processing $zip_file${NC}"
        echo "----------------------------------------"
    fi
done

# Prompt user to restart the device
read -p "Do you want to restart the device (y/n)? " restart_choice
if [ "$restart_choice" == "y" ]; then
    echo "Restarting device $DEVICE_NAME ($DEVICE_SERIAL)..."
    adb -s "$DEVICE_SERIAL" reboot
    echo -e "${RED}Device restarted.${NC}"
else
    echo -e "${RED}Thank you.${NC}"
fi

;;

2)

echo "Devices available:"
DEVICES=$(adb devices -l | grep -v "List of devices attached" | grep -v "^$")
echo "$DEVICES"

if [ -z "$DEVICES" ]; then
    echo "Error: No devices connected."
    exit 1
fi

# Prepare arrays to map serial numbers to device names
DEVICE_LIST=()
DEVICE_NAMES=()

# Populate the arrays with serial numbers and device names
while IFS= read -r line; do
    SERIAL=$(echo "$line" | awk '{print $1}')
    if [ -n "$SERIAL" ]; then
        DEVICE_NAME=$(echo "$line" | sed -e "s/^[^ ]* \(.*\)$/\1/")
        DEVICE_LIST+=("$SERIAL")
        DEVICE_NAMES+=("$DEVICE_NAME")
    fi
done <<< "$DEVICES"

# Display devices and process them automatically
if [ ${#DEVICE_LIST[@]} -gt 0 ]; then
    echo "Found ${#DEVICE_LIST[@]} device(s). Processing all connected devices..."

    # Iterate through all connected devices
    for i in "${!DEVICE_LIST[@]}"; do
        DEVICE_SERIAL="${DEVICE_LIST[$i]}"
        DEVICE_NAME="${DEVICE_NAMES[$i]}"
        echo "Using device: $DEVICE_NAME ($DEVICE_SERIAL)"

        # Determine the current working directory
        CURRENT_DIR=$(pwd)

        # Set both SCRIPT_DIR and ZIP_DIR to the current working directory
        SCRIPT_DIR="$CURRENT_DIR"
        ZIP_DIR="$CURRENT_DIR"

        # Check if any ZIP files exist
        ZIP_FILES=$(find "$ZIP_DIR" -name "*.zip")

        if [ -z "$ZIP_FILES" ]; then
            echo "No Train ZIP files found in the current directory. Please add the necessary files."
            exit 1
        fi

        # Find the latest version of bundletool-all.jar relative to SCRIPT_DIR
        BUNDLETOOL_JAR=$(find "$SCRIPT_DIR" -name "bundletool-all-*.jar" | sort -V | tail -n 1)

        # If bundletool is not found, download it
        if [ -z "$BUNDLETOOL_JAR" ]; then
            # Fetch the latest release page URL and extract the version tag using jq
            LATEST_VERSION=$(curl -s https://api.github.com/repos/google/bundletool/releases/latest | jq -r .tag_name)

            # Check if version extraction was successful
            if [ -z "$LATEST_VERSION" ]; then
                echo "Failed to retrieve the latest version. Please check the GitHub API."
                exit 1
            fi

            # Set the download URL for the bundletool jar file
            DOWNLOAD_URL="https://github.com/google/bundletool/releases/download/${LATEST_VERSION}/bundletool-all-${LATEST_VERSION}.jar"

            # Download the bundletool jar file
            echo "Downloading bundletool version ${LATEST_VERSION}..."
            curl -L -o "bundletool-all-${LATEST_VERSION}.jar" "$DOWNLOAD_URL"

            # Confirm the download
            if [ -f "bundletool-all-${LATEST_VERSION}.jar" ]; then
                echo "Download completed successfully: bundletool-all-${LATEST_VERSION}.jar"
            else
                echo "Download failed. Please check the URL and the file format."
                exit 1
            fi

            BUNDLETOOL_JAR="$SCRIPT_DIR/bundletool-all-${LATEST_VERSION}.jar"
        fi

        # Process each zip file in ZIP_DIR
        for zip_file in "$ZIP_DIR"/*.zip; do
            if [ -f "$zip_file" ]; then
                echo "Processing $zip_file on device $DEVICE_NAME ($DEVICE_SERIAL)"
                # Ensure the device ID is passed to the command
                java -jar "$BUNDLETOOL_JAR" install-multi-apks --device-id="$DEVICE_SERIAL" --enable-rollback --update-only --apks-zip="$zip_file"
                echo "Done processing $zip_file"
                echo "----------------------------------------"
            fi
        done
    done
else
    echo "Error: No devices available for selection."
    exit 1
fi

# Prompt user to restart the devices
read -p "Do you want to restart all devices (y/n)? " restart_choice
if [ "$restart_choice" == "y" ]; then
    for DEVICE_SERIAL in "${DEVICE_LIST[@]}"; do
        echo "Restarting device $DEVICE_SERIAL..."
        adb -s "$DEVICE_SERIAL" reboot
    done
    echo "All devices restarted."
else
    echo "No devices restarted. Thank you."
fi

;;

3)
   exit 0
   
   ;;
   
     
    esac


}

Install_apks(){

#!/bin/bash

echo "1. To install modules on single device"
echo "2. To install the modules on all the connected devices"
echo "3. Exit"

read -p "Enter the number of the choice to execute (1-3): " choice

case $choice in
1)
    # Device selection logic (You mentioned this is a custom function, so it's assumed to exist)
    Device_selections  # Retaining the device selection method
    
    # Directory where APK files are stored
    APK_DIR=$(pwd)
    
    # Function to install APK
    install_apk() {
        local apk_path="$1"
        local apk_name="$(basename "$apk_path")"
        
        echo "Installing $apk_name..."
        
        # Install APK
        if adb -s "$DEVICE_SERIAL" install "$apk_path"; then
            echo -e "${GREEN}Successfully installed $apk_name.${NC}" > /dev/null 2>&1
        else
            echo -e "${RED}Failed to install $apk_name.${NC}"
        fi
    }

    # Function to install all APKs in the directory
    install_all_apks() {
        echo "Installing all APKs in $APK_DIR..."
        for apk_file in "$APK_DIR"/*.apk; do
            install_apk "$apk_file"
        done
    }

    echo "Using device: $DEVICE_NAME ($DEVICE_SERIAL)"

    # List APK files in the directory
    APPS=()
    while IFS= read -r -d '' apk_file; do
        apk_filename=$(basename "$apk_file")
        APPS+=("$apk_filename")
    done < <(find "$APK_DIR" -name "*.apk" -type f -print0)

    # Display menu for APK selection
    if [ ${#APPS[@]} -eq 0 ]; then
        echo -e "${RED}No APK files found in $APK_DIR.${NC}"
        exit 1
    fi

    echo "Available Applications:"
    echo "1) Install all APKs"
    echo "2) Select specific applications to install"
    echo "3) Exit"
    echo "Enter your choice (1 or 2):"
    read -rp "Choice: " choice

    case $choice in
        1)
            install_all_apks
            ;;
        2)
            echo "Select the applications you want to install (enter numbers separated by spaces):"
            for index in "${!APPS[@]}"; do
                echo "$((index+1))) ${APPS[index]}"
            done

            selected_indices=()
            while true; do
                read -rp "Enter application numbers to install. For multiple applications, select each APK number with a space, then press Enter: " -a selected_indices
                if [ "${#selected_indices[@]}" -eq 0 ]; then
                    echo "No selection made."
                elif [[ "${selected_indices[*]}" =~ [^0-9\ ] ]]; then
                    echo "Invalid input. Please enter numbers separated by spaces."
                else
                    break
                fi
            done

            # Install selected APKs
            for index in "${selected_indices[@]}"; do
                if [ "$index" -gt 0 ] && [ "$index" -le "${#APPS[@]}" ]; then
                    apk_filename="${APPS[index-1]}"
                    apk_path="$APK_DIR/$apk_filename"
                    install_apk "$apk_path"
                else
                    echo -e "${RED}Invalid selection: $index. Skipping...${NC}"
                fi
            done
            ;;
        3)
            echo "Exiting."
            exit 0
            ;;
        *)
            echo -e "${RED}Invalid choice.${NC}"
            exit 1
            ;;
    esac

    echo "Installation process completed."

    ;;

2)

    # Second option: Install APKs on all connected devices
    echo "Devices available:"
    DEVICES=$(adb devices -l | grep -v "List of devices attached" | grep -v "^$")
    echo "$DEVICES"

    if [ -z "$DEVICES" ]; then
        echo "Error: No devices connected."
        exit 1
    fi

    # Prepare arrays to map serial numbers to device names
    DEVICE_LIST=()
    DEVICE_NAMES=()

    # Populate the arrays with serial numbers and device names
    while IFS= read -r line; do
        SERIAL=$(echo "$line" | awk '{print $1}')
        if [ -n "$SERIAL" ]; then
            DEVICE_NAME=$(echo "$line" | sed -e "s/^[^ ]* \(.*\)$/\1/")
            DEVICE_LIST+=("$SERIAL")
            DEVICE_NAMES+=("$DEVICE_NAME")
        fi
    done <<< "$DEVICES"

    # List APK files in the directory
    APK_DIR=$(pwd)
    APPS=()
    while IFS= read -r -d '' apk_file; do
        apk_filename=$(basename "$apk_file")
        APPS+=("$apk_filename")
    done < <(find "$APK_DIR" -name "*.apk" -type f -print0)

    # Display menu for APK selection
    if [ ${#APPS[@]} -eq 0 ]; then
        echo "No APK files found in $APK_DIR."
        exit 1
    fi

    # Function to install APK
    install_apk() {
        local device_serial="$1"
        local apk_path="$2"
        local apk_name="$(basename "$apk_path")"
        
        echo "Installing $apk_name on device $device_serial..."
        
        # Install APK
        if adb -s "$device_serial" install "$apk_path"; then
            echo "Successfully installed $apk_name on $device_serial."
        else
            echo "Failed to install $apk_name on $device_serial."
        fi
    }

    # Function to install all APKs to all devices
    install_apks_to_all_devices() {
        echo "Installing APKs to all connected devices..."
        
        # Loop over all connected devices
        for device_serial in "${DEVICE_LIST[@]}"; do
            for apk_file in "$APK_DIR"/*.apk; do
                install_apk "$device_serial" "$apk_file"
            done
        done
    }

    # Ask user for installation choice
    echo "Available Applications:"
    echo "1) Install all APKs on all devices"
    echo "2) Select specific applications to install on all devices"
    echo "3) Exit"
    read -rp "Enter your choice (1 or 2): " choice

    case $choice in
        1)
            install_apks_to_all_devices
            ;;
        2)
            echo "Select the applications you want to install (enter numbers separated by spaces):"
            for index in "${!APPS[@]}"; do
                echo "$((index+1))) ${APPS[index]}"
            done

            selected_indices=()
            while true; do
                read -rp "Enter application numbers to install. For multiple applications, select each APK number with a space, then press Enter: " -a selected_indices
                if [ "${#selected_indices[@]}" -eq 0 ]; then
                    echo "No selection made."
                elif [[ "${selected_indices[*]}" =~ [^0-9\ ] ]]; then
                    echo "Invalid input. Please enter numbers separated by spaces."
                else
                    break
                fi
            done

            # Install selected APKs to all devices
            for index in "${selected_indices[@]}"; do
                if [ "$index" -gt 0 ] && [ "$index" -le "${#APPS[@]}" ]; then
                    apk_filename="${APPS[index-1]}"
                    apk_path="$APK_DIR/$apk_filename"
                    # Now install this selected APK to all devices
                    for device_serial in "${DEVICE_LIST[@]}"; do
                        install_apk "$device_serial" "$apk_path"
                    done
                else
                    echo "Invalid selection: $index. Skipping..."
                fi
            done
            ;;
        3)
            echo "Exiting."
            exit 0
            ;;
        *)
            echo "Invalid choice."
            exit 1
            ;;
    esac

    echo "Installation process completed."

    ;;

3)
    echo "Exiting."
    exit 0
    ;;

*)
    echo "Invalid choice."
    exit 1
    ;;
esac


}
Rollback() {
Device_selections
# Function to rollback individual Big_Android trains
Big_Android() {
    echo "Select the Big_Android module to rollback:"
    echo "1) Primary Train"
    echo "2) Telemetry Train"
    echo "3) Adservices Train"
    echo "4) Tzdata Train"
    echo "5) Rollback All Big_Android Trains"
    echo "6) Back to Main Menu"

    read -p "Enter your choice (1-6): " module_choice

    case $module_choice in
        1)
            echo "Rollbacking Primary Train"
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.android.modulemetadata
            ;;
        2)
            echo "Rollbacking Telemetry Train"
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.mainline.telemetry
            ;;
        3)
            echo "Rollbacking Adservices Train"
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.mainline.adservices
            ;;
        4)
            echo "Rollbacking Tzdata Train"
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.android.tzdata2
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.android.tzdata3
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.android.tzdata4
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.android.tzdata5
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.android.tzdata6
            ;;
        5)
            echo "Rollbacking Primary Train"
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.android.modulemetadata
            echo "Rollbacking Telemetry Train"
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.mainline.telemetry
            echo "Rollbacking Adservices Train"
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.mainline.adservices
            echo "Rollbacking Tzdata Train"
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.android.tzdata2
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.android.tzdata3
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.android.tzdata4
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.android.tzdata5
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.android.tzdata6
            ;;
        6)
            return
            ;;
        *)
            echo "Invalid selection. Returning to main menu."
            ;;
    esac
    PromptReboot
}

# Function to rollback individual Go_Android trains
Go_Android() {
    echo "Select the Go_Android module to rollback:"
    echo "1) Go Primary Train"
    echo "2) Go Non-updatable Train"
    echo "3) Go Telemetry Train"
    echo "4) Go Tzdata Train"
    echo "5) Rollback All Go_Android Trains"
    echo "6) Back to Main Menu"

    read -p "Enter your choice (1-6): " module_choice

    case $module_choice in
        1)
            echo "Rollbacking Go Primary Train"
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.mainline.go.primary
            ;;
        2)
            echo "Rollbacking Go Non-updatable Train"
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.mainline.go.mediaprovider
            ;;
        3)
            echo "Rollbacking Go Telemetry Train"
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.mainline.go.telemetry
            ;;
        4)
            echo "Rollbacking Go Tzdata Train"
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.android.tzdata4
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.android.tzdata5
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.android.tzdata6
            ;;
        5)
            echo "Rollbacking Go Primary Train"
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.mainline.go.primary
            echo "Rollbacking Go Non-updatable Train"
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.mainline.go.mediaprovider
            echo "Rollbacking Go Telemetry Train"
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.mainline.go.telemetry
            echo "Rollbacking Go Tzdata Train"
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.android.tzdata4
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.android.tzdata5
            adb -s "$DEVICE_SERIAL" shell pm rollback-app com.google.android.tzdata6
            ;;
        *)
            echo "Invalid selection. Returning to main menu."
            ;;
    esac
    PromptReboot
}

# Function to prompt user for device reboot
PromptReboot() {
    read -p "Do you want to restart the device? (y/n): " reboot_choice
    if [ "$reboot_choice" = "y" ]; then
        echo "Rebooting device..."
        adb -s "$DEVICE_SERIAL" reboot
        exit 1
    else
        echo "Skipping reboot."
        exit 1
    fi
}

# Display main menu and get user input
while true; do
    echo "Select the rollback option:"
    echo "1) Rollback Big_Android"
    echo "2) Rollback Go_Android"
    echo "3) Exit"

    read -p "Enter your choice (1-3): " choice

    case $choice in
        1)
            Big_Android
            ;;
        2)
            Go_Android
            ;;
        3)
            echo "Exiting."
            exit 0
            ;;
        *)
            echo "Invalid choice. Exiting."
            exit 1
            ;;
    esac
done
}
ROR(){
Device_selections
echo "Using device: $DEVICE_NAME ($DEVICE_SERIAL)"

ROR_Setup() {
echo "Executing reboot readliness command"

adb -s "$DEVICE_SERIAL" shell device_config put reboot_readiness idle_polling_interval_ms 10000 &&
adb -s "$DEVICE_SERIAL" shell device_config put reboot_readiness active_polling_interval_ms 10000 &&
adb -s "$DEVICE_SERIAL" shell device_config put reboot_readiness interactivity_threshold_ms 60000 &&
adb -s "$DEVICE_SERIAL" shell device_config put reboot_readiness disable_app_activity_check true

sleep 5 

echo "Running logcat to verfiy the ROR logs"

 if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        # Linux (Debian/Ubuntu)
       sudo systemd-inhibit --what=handle-lid-switch --mode=block adb -s "$DEVICE_SERIAL" logcat | grep -e "SSM:" -e "SysU:" -e "RH:" -e "UChk::Mainline:"
       
   elif [[ "$OSTYPE" == "darwin"* ]]; then
        sudo pmset noidle & adb -s "$DEVICE_SERIAL" logcat | grep -e "SSM:" -e "SysU:" -e "RH:" -e "UChk::Mainline:"
        
    else
        echo "unable to find which laptop to execute."
        exit 1
    fi

}
After_ROR(){
command_output1=$(adb -s "$DEVICE_SERIAL" shell dumpsys activity | grep LOCKED)

# Check if the output exactly matches RUNNING_UNLOCKED
if echo "$command_output1" | grep -q "User #0: state=RUNNING_UNLOCKED"; then
    echo -e "${GREEN}Test passed. The output is RUNNING_UNLOCKED.${NC}"
    exit 1
else
    echo -e "${RED}Test failed. The output is not RUNNING_UNLOCKED. Current output: $command_output1${NC}"
    exit 1
fi
}
# Main menu for user selection
while true; do
    echo "Select the action to perform:"
    echo "1) ROR_Setup"
    echo "2) After ROR device reboot locked status check"
    echo "3) Exit"

    read -p "Enter your choice (1-3): " choice
    case $choice in
        1)
           ROR_Setup
            ;;
        2)
           After_ROR
            ;;
      
        3)
            echo "Exiting."
            exit 0
            ;;
        *)
            echo "Invalid selection. Please try again."
            ;;
    esac
done
}
Bulk_files_creation() {
#!/bin/bash

# Function to check and install missing packages
install_package() {
    package_name=$1
    if ! dpkg -l | grep -q "$package_name"; then
        echo "$package_name is not installed. Installing..."
        sudo apt-get update
        sudo apt-get install -y "$package_name"
    else
        echo "$package_name is already installed."
    fi
}

# Function to generate images
generate_images() {
    # Get the current directory using pwd
    current_dir=$(pwd)

    # Directory where images will be saved (current directory)
    output_dir="$current_dir/test_images"

    # Create the output directory if it doesn't exist
    mkdir -p "$output_dir"

    # Prompt the user for the number of images to generate
    echo "How many images would you like to generate?"
    read -p "Enter the total number of images: " num_images

    # Validate the input (ensure it's a number and greater than 0)
    if ! [[ "$num_images" =~ ^[0-9]+$ ]] || [ "$num_images" -le 0 ]; then
        echo "Invalid input. Please enter a valid number greater than 0."
        exit 1
    fi

    # Image size and dimensions (32x32 pixels for small size)
    width=32
    height=32

    # Loop to create the images
    for ((i=1; i<=num_images; i++)); do
        # Generate random color (in hex format)
        color=$(printf "#%02X%02X%02X" $((RANDOM % 256)) $((RANDOM % 256)) $((RANDOM % 256)))

        # Image filename (e.g., image_1.png, image_2.png, etc.)
        filename="$output_dir/image_$i.png"

        # Create the image using ImageMagick
        convert -size ${width}x${height} xc:$color "$filename"

    done

    echo "Created $num_images images in $output_dir"
}

# Function to generate music
generate_music() {
    # Get the current directory using pwd
    current_dir=$(pwd)

    # Prompt the user for the total number of music files to generate
    echo "How many music files would you like to generate?"
    read -p "Enter the total number of music files: " num_music_files

    # Validate the input (ensure it's a number and greater than 0)
    if ! [[ "$num_music_files" =~ ^[0-9]+$ ]] || [ "$num_music_files" -le 0 ]; then
        echo "Invalid input. Please enter a valid number greater than 0."
        exit 1
    fi

    # Music file format (MP3)
    music_format="mp3"

    # Directory for all the generated music files (single folder)
    music_dir="$current_dir/test_music"

    # Create the music directory if it doesn't exist
    mkdir -p "$music_dir"

    # Generate music files using ffmpeg with random sine wave tones
    for ((i=1; i<=num_music_files; i++)); do
        # Generate a random frequency between 100 and 1000 Hz
        frequency=$((RANDOM % 901 + 100))
        
        # Generate a music file name
        music_file="$music_dir/music_file_$i.$music_format"
        
        # Generate a 5-second sine wave with the random frequency using ffmpeg
        ffmpeg -f lavfi -t 5 -i "sine=frequency=$frequency:duration=5" -ac 2 -ar 44100 "$music_file" -y
        
        echo "Generated: $music_file with frequency $frequency Hz"
    done

    echo "Generated $num_music_files music files in the '$music_dir' folder."
}

# Function to generate videos
generate_videos() {
    # Get the current directory using pwd
    current_dir=$(pwd)

    # Directory where videos will be saved (current directory)
    output_dir="$current_dir/test_videos"

    # Create the output directory if it doesn't exist
    mkdir -p "$output_dir"

    # Prompt the user for the number of video files to generate
    echo "How many video files would you like to generate?"
    read -p "Enter the total number of video files: " num_videos

    # Validate the input (ensure it's a number and greater than 0)
    if ! [[ "$num_videos" =~ ^[0-9]+$ ]] || [ "$num_videos" -le 0 ]; then
        echo "Invalid input. Please enter a valid number greater than 0."
        exit 1
    fi

    # Prompt the user for the path of the MP3 audio file
    echo "Please provide the path to the audio file (MP3 format, or leave blank to generate without audio):"
    read -p "Enter the audio file path: " audio_file

    # Validate the audio file path if it's provided
    if [[ -n "$audio_file" ]]; then
        if ! [[ -f "$audio_file" && "$audio_file" =~ \.mp3$ ]]; then
            echo "Invalid audio file path or file type. Please ensure the file exists and is an MP3."
            exit 1
        fi
        # Video duration (in seconds) based on the duration of the audio file
        audio_duration=$(ffmpeg -i "$audio_file" 2>&1 | grep "Duration" | awk '{print $2}' | tr -d ,)
        duration_seconds=$(echo $audio_duration | awk -F: '{print ($1 * 3600) + ($2 * 60) + $3}')
    else
        # If no audio is provided, set a default duration (e.g., 10 seconds)
        duration_seconds=10
    fi

    # Video size and dimensions (e.g., 640x480 for standard resolution)
    width=640
    height=480

    # Loop to create the videos
    for ((i=1; i<=num_videos; i++)); do
        # Generate random color (in hex format)
        color=$(printf "#%02X%02X%02X" $((RANDOM % 256)) $((RANDOM % 256)) $((RANDOM % 256)))

        # Video filename (e.g., video_1.mp4, video_2.mp4, etc.)
        filename="$output_dir/video_$i.mp4"

        if [[ -n "$audio_file" ]]; then
            # Generate the video with a random color background and audio
            ffmpeg -f lavfi -t $duration_seconds -i "color=$color:s=${width}x${height}:d=$duration_seconds" -i "$audio_file" -c:v libx264 -c:a aac -strict experimental "$filename" -y
        else
            # Generate the video with just a random color background (no audio)
            ffmpeg -f lavfi -t $duration_seconds -i "color=$color:s=${width}x${height}:d=$duration_seconds" "$filename" -y
        fi

        echo "Generated: $filename"
    done

    echo "Generated $num_videos video files in the '$output_dir' folder."
}

# Install missing dependencies
install_package "imagemagick"
install_package "ffmpeg"

# Interactive menu
while true; do
    echo "Choose what you want to generate:"
    echo "1. Generate Images"
    echo "2. Generate Music Files"
    echo "3. Generate Video Files"
    echo "4. Exit"

    read -p "Enter your choice (1/2/3/4): " choice

    case $choice in
        1) 
            generate_images
            ;;
        2)
            generate_music
            ;;
        3)
            generate_videos
            ;;
        4)
            echo "Exiting..."
            exit 0
            ;;
        *)
            echo "Invalid choice. Please choose again."
            ;;
    esac
done
}

# Display available options
echo "Which scripts you want to execute:"
echo "1. Sideload"
echo "2. Rollback"
echo "3. Install Applications"
echo "4. Apex Multiuser_BA"
echo "5. Apex Multiuser Go"
echo "6. ROR execution command"
echo "7. Bulk files creation"
echo "8. Exit"

# Prompt the user for their choice
read -p "Enter the number of the script to execute (1-8): " choice

# Execute the corresponding function based on user input
case $choice in
    
    4)
        Apex_multiuser_BA
        ;;
    5)
        Apex_multiuser_Go
        ;;
   
    1)
        sideload
        ;;
    3)
        Install_apks
        ;;
    2)
    
        Rollback
        ;;
        
    6)
    
        ROR
        ;;
        
    7)
       Bulk_files_creation
       ;;
       
    8)
        echo "Exiting."
        exit 0
        ;;
    *)
        echo "Invalid selection."
        exit 1
        ;;
esac

echo "Script executed successfully."
